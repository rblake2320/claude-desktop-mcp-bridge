/**
 * Demo Fixture Generator
 *
 * Creates a small self-contained repo with intentional compliance findings
 * that all 3 scanners (gitleaks, npm audit, checkov) will detect.
 *
 * Purpose: let users try the full compliance workflow end-to-end without
 * touching real code. Every finding is intentional and clearly marked.
 */

import { mkdirSync, writeFileSync, existsSync, readFileSync, readdirSync } from 'node:fs';
import { resolve } from 'node:path';
import { assertPathUnder, validateRepoPath } from '../shared/path-policy.js';

// ── Types ────────────────────────────────────────────────────────

export interface CreateDemoFixtureInput {
  outputDir?: string;
  preset?: 'soc2-demo';
}

export interface CreateDemoFixtureResponse {
  outputDir: string;
  filesCreated: string[];
  scannerTargets: {
    gitleaks: string[];
    npm_audit: string[];
    checkov: string[];
  };
  message: string;
}

// ── Fixture Content ──────────────────────────────────────────────

const FIXTURE_README = `# Compliance Navigator Demo Repo

> **DO NOT COMMIT THIS REPO TO A REAL PROJECT.**
> This directory contains intentional security findings for testing purposes only.

## What's Here

This demo repo was generated by \`compliance.create_demo_fixture\` to let you
test the full Compliance Navigator workflow:

1. **Scan**: \`compliance.scan_repo({ repoPath: "<this-dir>" })\`
2. **Audit Packet**: \`compliance.generate_audit_packet({ repoPath: "<this-dir>" })\`
3. **Remediation**: \`compliance.plan_remediation({ repoPath: "<this-dir>" })\`
4. **Tickets**: \`compliance.create_tickets({ repoPath: "<this-dir>", dryRun: true })\`
5. **Dashboard**: \`compliance.open_dashboard({ repoPath: "<this-dir>" })\`

## Intentional Findings

| Scanner      | Finding                              | Severity |
|-------------|--------------------------------------|----------|
| gitleaks    | Fake AWS access key in config.env    | high     |
| gitleaks    | Fake GitHub token in .env.example    | high     |
| npm audit   | Known vulnerable dependencies        | varies   |
| checkov     | S3 bucket without encryption         | medium   |
| checkov     | S3 bucket without versioning         | medium   |
| checkov     | S3 bucket without logging            | low      |
| checkov     | Security group allowing 0.0.0.0/0    | high     |

All secrets are fake test values that follow known patterns scanners detect.
They are not real credentials.
`;

const FIXTURE_GITIGNORE = `# Compliance Navigator demo repo
node_modules/
.compliance/
*.log

# Fake secrets — do NOT commit these even though they are test values.
# External scanners (GitHub secret scanning, etc.) may flag them.
config.env
.env.example
`;

// Fake secret file for gitleaks detection
const FIXTURE_CONFIG_ENV = `# ╔══════════════════════════════════════════════════════════════╗
# ║  TEST ONLY - FAKE CREDENTIALS FOR SCANNER TESTING          ║
# ║  These are not real. They exist to trigger gitleaks.        ║
# ╚══════════════════════════════════════════════════════════════╝

# Fake AWS access key (follows AKIA pattern that gitleaks detects)
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Fake database URL
DATABASE_URL=postgresql://admin:supersecretpassword123@db.example.com:5432/mydb
`;

const FIXTURE_ENV_EXAMPLE = `# ╔══════════════════════════════════════════════════════════════╗
# ║  TEST ONLY - FAKE TOKEN FOR SCANNER TESTING                ║
# ╚══════════════════════════════════════════════════════════════╝

# Fake GitHub personal access token (follows ghp_ pattern)
GITHUB_TOKEN=ghp_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef12

# Fake Slack webhook (placeholder pattern — not a real webhook URL format)
SLACK_WEBHOOK=https://hooks.example.invalid/services/FAKE000000/FAKE000000/FAKE_WEBHOOK_FOR_TESTING
`;

// Vulnerable package.json for npm audit
const FIXTURE_PACKAGE_JSON = `{
  "name": "compliance-demo-fixture",
  "version": "0.0.1",
  "private": true,
  "description": "DO NOT USE - Intentionally vulnerable demo for Compliance Navigator testing",
  "dependencies": {
    "lodash": "4.17.20",
    "minimist": "1.2.5",
    "node-fetch": "2.6.1",
    "tar": "6.1.0",
    "path-parse": "1.0.6"
  }
}
`;

// Terraform files for checkov detection
const FIXTURE_MAIN_TF = `# ╔══════════════════════════════════════════════════════════════╗
# ║  TEST ONLY - Intentional IaC misconfigs for checkov         ║
# ╚══════════════════════════════════════════════════════════════╝

provider "aws" {
  region = "us-east-1"
}

# S3 bucket without encryption, versioning, or logging
# checkov will flag: CKV_AWS_18, CKV_AWS_19, CKV_AWS_21, CKV2_AWS_6
resource "aws_s3_bucket" "demo_insecure" {
  bucket = "compliance-demo-insecure-bucket"
  acl    = "public-read"

  tags = {
    Purpose = "compliance-navigator-demo"
    Warning = "DO-NOT-DEPLOY"
  }
}

# Security group allowing all inbound traffic
# checkov will flag: CKV_AWS_24, CKV_AWS_25
resource "aws_security_group" "demo_open" {
  name        = "demo-wide-open-sg"
  description = "Intentionally insecure for testing"

  ingress {
    from_port   = 0
    to_port     = 65535
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Purpose = "compliance-navigator-demo"
    Warning = "DO-NOT-DEPLOY"
  }
}

# EC2 instance without encryption
# checkov will flag: CKV_AWS_8
resource "aws_instance" "demo_unencrypted" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"

  root_block_device {
    encrypted = false
  }

  tags = {
    Purpose = "compliance-navigator-demo"
    Warning = "DO-NOT-DEPLOY"
  }
}
`;

// Docker file for checkov to scan
const FIXTURE_DOCKERFILE = `# TEST ONLY - Intentional Dockerfile misconfigs for checkov
# checkov will flag: CKV_DOCKER_2, CKV_DOCKER_3
FROM ubuntu:latest

# Running as root (CKV_DOCKER_3)
RUN apt-get update && apt-get install -y curl

# No HEALTHCHECK defined (CKV_DOCKER_2)
EXPOSE 8080

CMD ["echo", "This is a demo fixture - do not run"]
`;

// Gitleaks config to exclude the .compliance/ output dir
const FIXTURE_GITLEAKS_TOML = `title = "Compliance Navigator Demo - gitleaks config"

[allowlist]
  description = "Exclude compliance output directory"
  paths = [
    '''.compliance/.*''',
  ]
`;

// ── Generator ────────────────────────────────────────────────────

interface FileEntry {
  relativePath: string;
  content: string;
}

function getSoc2DemoFiles(): FileEntry[] {
  return [
    { relativePath: 'README.md', content: FIXTURE_README },
    { relativePath: '.gitignore', content: FIXTURE_GITIGNORE },
    { relativePath: '.gitleaks.toml', content: FIXTURE_GITLEAKS_TOML },
    { relativePath: 'config.env', content: FIXTURE_CONFIG_ENV },
    { relativePath: '.env.example', content: FIXTURE_ENV_EXAMPLE },
    { relativePath: 'package.json', content: FIXTURE_PACKAGE_JSON },
    { relativePath: 'infra/main.tf', content: FIXTURE_MAIN_TF },
    { relativePath: 'infra/Dockerfile', content: FIXTURE_DOCKERFILE },
  ];
}

export function createDemoFixture(input: CreateDemoFixtureInput): CreateDemoFixtureResponse {
  const outputDir = resolve(input.outputDir ?? resolve(process.cwd(), 'compliance-demo-repo'));

  // Validate the output directory path
  const pathCheck = validateRepoPath(outputDir);
  if (!pathCheck.valid) {
    throw new Error(`Invalid output directory: ${pathCheck.reason}`);
  }

  // Don't overwrite existing directories unless they are a previous fixture
  if (existsSync(outputDir)) {
    const readmePath = resolve(outputDir, 'README.md');
    if (existsSync(readmePath)) {
      const content = readFileSync(readmePath, 'utf-8');
      if (!content.includes('compliance.create_demo_fixture')) {
        throw new Error(
          `Directory already exists and does not appear to be a previous demo fixture: ${outputDir}. ` +
          'Remove it first or choose a different outputDir.'
        );
      }
      // Allow overwrite of existing fixture (README contains our marker)
    } else {
      // Directory exists but no README — check if it has non-fixture files
      const entries = readdirSync(outputDir);
      if (entries.length > 0) {
        throw new Error(
          `Directory already exists and is not empty: ${outputDir}. ` +
          'Remove it first or choose a different outputDir.'
        );
      }
    }
  }

  // Create the directory
  mkdirSync(outputDir, { recursive: true });

  const files = getSoc2DemoFiles();
  const filesCreated: string[] = [];

  for (const file of files) {
    const fullPath = resolve(outputDir, file.relativePath);

    // Validate each file stays under outputDir
    assertPathUnder(outputDir, fullPath);

    // Create subdirectories if needed
    const dir = resolve(fullPath, '..');
    mkdirSync(dir, { recursive: true });

    writeFileSync(fullPath, file.content, 'utf-8');
    filesCreated.push(file.relativePath);
  }

  return {
    outputDir,
    filesCreated,
    scannerTargets: {
      gitleaks: ['config.env', '.env.example'],
      npm_audit: ['package.json'],
      checkov: ['infra/main.tf', 'infra/Dockerfile'],
    },
    message: [
      `Demo fixture created at: ${outputDir}`,
      '',
      `${filesCreated.length} files written with intentional findings for all 3 scanners.`,
      '',
      'Next steps:',
      `  1. compliance.scan_repo({ repoPath: "${outputDir.replace(/\\/g, '\\\\')}" })`,
      `  2. compliance.open_dashboard({ repoPath: "${outputDir.replace(/\\/g, '\\\\')}" })`,
      '',
      'All secrets are fake test values. All IaC configs are marked DO-NOT-DEPLOY.',
    ].join('\n'),
  };
}
